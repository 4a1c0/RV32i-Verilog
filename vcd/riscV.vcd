$date
	Fri Sep 20 15:48:39 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb $end
$scope module package_inst $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var wire 1 # we_mem_data $end
$var wire 32 $ val_mem_prog [31:0] $end
$var wire 32 % val_mem_data_write [31:0] $end
$var wire 32 & val_mem_data_read [31:0] $end
$var wire 10 ' addr_mem_prog [9:0] $end
$var wire 10 ( addr_mem_data [9:0] $end
$scope module core_inst $end
$var wire 1 ! clk $end
$var wire 1 ) is_branch_t $end
$var wire 1 " rst_n $end
$var wire 1 # we_mem_data_o $end
$var wire 1 * we_reg_file $end
$var wire 32 + val_mem_prog_i [31:0] $end
$var wire 32 , val_mem_data_write_o [31:0] $end
$var wire 32 - val_mem_data_read_i [31:0] $end
$var wire 32 . rs2_reg_file [31:0] $end
$var wire 32 / rs2_exec_unit_t [31:0] $end
$var wire 32 0 rs1_reg_file [31:0] $end
$var wire 32 1 rs1_exec_unit_t [31:0] $end
$var wire 5 2 r_num_write_reg_file [4:0] $end
$var wire 5 3 r2_num_read_reg_file [4:0] $end
$var wire 5 4 r1_num_read_reg_file [4:0] $end
$var wire 1 5 mem_w_t $end
$var wire 1 6 mem_to_reg_t $end
$var wire 1 7 is_load_store_t $end
$var wire 1 8 is_imm_rs2 $end
$var wire 1 9 is_imm_rs1 $end
$var wire 32 : imm_val_rs2 [31:0] $end
$var wire 32 ; imm_val_rs1 [31:0] $end
$var wire 32 < data_in_reg_file [31:0] $end
$var wire 10 = addr_mem_prog_o [9:0] $end
$var wire 10 > addr_mem_data_o [9:0] $end
$var wire 4 ? ALU_op_t [3:0] $end
$scope module controlUnit_inst $end
$var wire 10 @ pc_i [9:0] $end
$var wire 32 A instruction [31:0] $end
$var reg 4 B ALU_op [3:0] $end
$var reg 3 C funct3 [2:0] $end
$var reg 7 D funct7 [6:0] $end
$var reg 12 E imm12 [11:0] $end
$var reg 12 F imm12b [11:0] $end
$var reg 20 G imm20 [19:0] $end
$var reg 20 H imm20j [19:0] $end
$var reg 32 I imm_val_rs1_o [31:0] $end
$var reg 32 J imm_val_rs2_o [31:0] $end
$var reg 1 9 is_imm_rs1_o $end
$var reg 1 8 is_imm_rs2_o $end
$var reg 1 7 is_load_store $end
$var reg 1 6 mem_to_reg $end
$var reg 1 5 mem_w $end
$var reg 7 K opcode [6:0] $end
$var reg 5 L r1_addr [4:0] $end
$var reg 5 M r2_addr [4:0] $end
$var reg 5 N rd [4:0] $end
$var reg 5 O reg_addr [4:0] $end
$var reg 1 * reg_r $end
$var reg 5 P rs1 [4:0] $end
$var reg 5 Q rs2 [4:0] $end
$upscope $end
$scope module exec_unit_inst $end
$var wire 4 R ALU_op [3:0] $end
$var wire 1 ) is_branch $end
$var wire 1 7 is_loadstore $end
$var wire 32 S mem_o [31:0] $end
$var wire 32 T val_mem_data_write_o [31:0] $end
$var wire 32 U val_mem_data_read_i [31:0] $end
$var wire 32 V s2 [31:0] $end
$var wire 32 W s1 [31:0] $end
$var wire 32 X d [31:0] $end
$var wire 32 Y alu_o [31:0] $end
$var wire 10 Z addr_mem_data_o [9:0] $end
$scope module ALU $end
$var wire 4 [ ALU_op [3:0] $end
$var wire 5 \ shift [4:0] $end
$var wire 32 ] s2 [31:0] $end
$var wire 32 ^ s1 [31:0] $end
$var reg 32 _ d [31:0] $end
$upscope $end
$scope module LIS $end
$var wire 4 ` LIS_op [3:0] $end
$var wire 32 a addr_mem_i [31:0] $end
$var wire 32 b val_mem_read_o [31:0] $end
$var wire 32 c val_mem_write_i [31:0] $end
$var wire 32 d val_mem_read_i [31:0] $end
$var wire 10 e addr_mem_o [9:0] $end
$var reg 32 f val_mem_write_o [31:0] $end
$upscope $end
$upscope $end
$scope module mux_rs1_exec_inst $end
$var wire 32 g b [31:0] $end
$var wire 1 9 select $end
$var wire 32 h out [31:0] $end
$var wire 32 i a [31:0] $end
$upscope $end
$scope module mux_rs2_exec_inst $end
$var wire 32 j b [31:0] $end
$var wire 1 8 select $end
$var wire 32 k out [31:0] $end
$var wire 32 l a [31:0] $end
$upscope $end
$scope module program_counter_inst $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var reg 10 m addr [9:0] $end
$upscope $end
$scope module reg_file_inst $end
$var wire 1 ! clk $end
$var wire 32 n data_in [31:0] $end
$var wire 5 o r1_num_read [4:0] $end
$var wire 5 p r2_num_read [4:0] $end
$var wire 5 q r_num_write [4:0] $end
$var wire 1 " rst_n $end
$var wire 1 * we $end
$var wire 32 r rs2 [31:0] $end
$var wire 32 s rs1 [31:0] $end
$scope begin REG $end
$var integer 32 t j [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module mem_data_inst $end
$var wire 10 u addr [9:0] $end
$var wire 1 ! clk $end
$var wire 32 v data_in [31:0] $end
$var wire 1 " rst_n $end
$var wire 1 # we $end
$var reg 32 w data_out [31:0] $end
$scope begin MEM_WRITE $end
$var integer 32 x j [31:0] $end
$upscope $end
$upscope $end
$scope module mem_prog_inst $end
$var wire 10 y addr [9:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var reg 32 z data_out [31:0] $end
$scope begin MEM_READ $end
$var integer 32 { j [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000000000 {
bx z
b0 y
b10000000000 x
bx w
bx v
bx u
b100000 t
bx s
bx r
bx q
bx p
bx o
bx n
b0 m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bz b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bz S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
b0 @
bx ?
bx >
b0 =
bx <
bx ;
bx :
09
08
x7
06
05
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
x*
z)
bx (
b0 '
bx &
bx %
bx $
z#
0"
0!
$end
#50000
b10000000000 {
b10000000000 x
b100000 t
1!
#100000
0!
1"
#150000
b100 '
b100 =
b100 @
b100 m
b100 y
b100 (
b100 >
b100 Z
b100 e
b100 u
b0 \
b11111111111111111111000000000100 Y
b11111111111111111111000000000100 _
b11111111111111111111000000000100 a
b0 %
b0 ,
b0 T
b0 f
b0 v
b100 1
b100 W
b100 ^
b100 h
b11111111111111111111000000000000 /
b11111111111111111111000000000000 V
b11111111111111111111000000000000 ]
b11111111111111111111000000000000 c
b11111111111111111111000000000000 k
b10 2
b10 O
b10 q
1*
b0 ?
b0 B
b0 R
b0 [
b0 `
b100 ;
b100 I
b100 g
19
b11111111111111111111000000000000 :
b11111111111111111111000000000000 J
b11111111111111111111000000000000 j
18
b11111 Q
b11111 P
b101111110001 F
b11111111111111111111 H
b10 N
b111111111111 E
b11111111111111111111 G
b111 C
b1111111 D
b10111 K
b11111111111111111111000100010111 $
b11111111111111111111000100010111 +
b11111111111111111111000100010111 A
b11111111111111111111000100010111 z
1!
#200000
0!
#250000
b1000 (
b1000 >
b1000 Z
b1000 e
b1000 u
b1000 1
b1000 W
b1000 ^
b1000 h
b1000 ;
b1000 I
b1000 g
b1000 '
b1000 =
b1000 @
b1000 m
b1000 y
b10101010101010101010000000001000 Y
b10101010101010101010000000001000 _
b10101010101010101010000000001000 a
b10101010101010101010000000000000 /
b10101010101010101010000000000000 V
b10101010101010101010000000000000 ]
b10101010101010101010000000000000 c
b10101010101010101010000000000000 k
b11 2
b11 O
b11 q
b10101010101010101010000000000000 :
b10101010101010101010000000000000 J
b10101010101010101010000000000000 j
b1010 Q
b10101 P
b110101010001 F
b11010101000101010101 H
b11 N
b101010101010 E
b10101010101010101010 G
b10 C
b1010101 D
18
19
b10101010101010101010000110010111 $
b10101010101010101010000110010111 +
b10101010101010101010000110010111 A
b10101010101010101010000110010111 z
1!
#300000
0!
#350000
b1100 (
b1100 >
b1100 Z
b1100 e
b1100 u
b1100 1
b1100 W
b1100 ^
b1100 h
b1100 ;
b1100 I
b1100 g
b1100 '
b1100 =
b1100 @
b1100 m
b1100 y
b1010101010101010101000000001100 Y
b1010101010101010101000000001100 _
b1010101010101010101000000001100 a
b1010101010101010101000000000000 /
b1010101010101010101000000000000 V
b1010101010101010101000000000000 ]
b1010101010101010101000000000000 c
b1010101010101010101000000000000 k
b100 2
b100 O
b100 q
b1010101010101010101000000000000 :
b1010101010101010101000000000000 J
b1010101010101010101000000000000 j
b10101 Q
b1010 P
b1010100010 F
b101010111010101010 H
b100 N
b10101010101 E
b1010101010101010101 G
b101 C
b101010 D
18
19
b1010101010101010101001000010111 $
b1010101010101010101001000010111 +
b1010101010101010101001000010111 A
b1010101010101010101001000010111 z
1!
#400000
0!
#450000
b10000 '
b10000 =
b10000 @
b10000 m
b10000 y
bx (
bx >
bx Z
bx e
bx u
bx \
bx %
bx ,
bx T
bx f
bx v
bx Y
bx _
bx a
bx /
bx V
bx ]
bx c
bx k
bx 1
bx W
bx ^
bx h
b0 Q
b0 P
b0 F
b0 H
b0 N
b0 E
b0 G
b0 C
b0 D
b0 K
08
09
b0 $
b0 +
b0 A
b0 z
1!
#500000
0!
#550000
b10100 '
b10100 =
b10100 @
b10100 m
b10100 y
1!
#600000
0!
