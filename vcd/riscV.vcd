$date
	Sun Sep 22 19:15:46 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb $end
$scope module package_inst $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var wire 1 # we_mem_data $end
$var wire 32 $ val_mem_prog [31:0] $end
$var wire 32 % val_mem_data_write [31:0] $end
$var wire 32 & val_mem_data_read [31:0] $end
$var wire 10 ' addr_mem_prog [9:0] $end
$var wire 10 ( addr_mem_data [9:0] $end
$scope module core_inst $end
$var wire 1 ! clk $end
$var wire 1 ) is_branch_t $end
$var wire 1 " rst_n $end
$var wire 1 * we_reg_file $end
$var wire 1 # we_mem_data_o $end
$var wire 32 + val_mem_prog_i [31:0] $end
$var wire 32 , val_mem_data_write_o [31:0] $end
$var wire 32 - val_mem_data_read_i [31:0] $end
$var wire 32 . rs2_reg_file [31:0] $end
$var wire 32 / rs2_exec_unit_t [31:0] $end
$var wire 32 0 rs1_reg_file [31:0] $end
$var wire 32 1 rs1_exec_unit_t [31:0] $end
$var wire 5 2 r_num_write_reg_file [4:0] $end
$var wire 5 3 r2_num_read_reg_file [4:0] $end
$var wire 5 4 r1_num_read_reg_file [4:0] $end
$var wire 1 5 mem_to_reg_t $end
$var wire 1 6 is_load_store_t $end
$var wire 1 7 is_imm_rs2 $end
$var wire 1 8 is_imm_rs1 $end
$var wire 32 9 imm_val_rs2 [31:0] $end
$var wire 32 : imm_val_rs1 [31:0] $end
$var wire 32 ; data_in_reg_file [31:0] $end
$var wire 10 < addr_mem_prog_o [9:0] $end
$var wire 10 = addr_mem_data_o [9:0] $end
$var wire 3 > LIS_op_t [2:0] $end
$var wire 4 ? ALU_op_t [3:0] $end
$scope module controlUnit_inst $end
$var wire 10 @ pc_i [9:0] $end
$var wire 32 A instruction [31:0] $end
$var reg 4 B ALU_op [3:0] $end
$var reg 3 C LIS_op [2:0] $end
$var reg 3 D funct3 [2:0] $end
$var reg 7 E funct7 [6:0] $end
$var reg 12 F imm12 [11:0] $end
$var reg 12 G imm12b [11:0] $end
$var reg 12 H imm12s [11:0] $end
$var reg 20 I imm20 [19:0] $end
$var reg 20 J imm20j [19:0] $end
$var reg 32 K imm_val_rs1_o [31:0] $end
$var reg 32 L imm_val_rs2_o [31:0] $end
$var reg 1 8 is_imm_rs1_o $end
$var reg 1 7 is_imm_rs2_o $end
$var reg 1 6 is_load_store $end
$var reg 1 5 mem_to_reg $end
$var reg 1 # mem_w $end
$var reg 7 M opcode [6:0] $end
$var reg 5 N r1_addr [4:0] $end
$var reg 5 O r2_addr [4:0] $end
$var reg 5 P rd [4:0] $end
$var reg 5 Q reg_addr [4:0] $end
$var reg 1 * reg_r $end
$var reg 5 R rs1 [4:0] $end
$var reg 5 S rs2 [4:0] $end
$upscope $end
$scope module exec_unit_inst $end
$var wire 4 T ALU_op [3:0] $end
$var wire 3 U LIS_op [2:0] $end
$var wire 1 ) is_branch $end
$var wire 1 6 is_loadstore $end
$var wire 32 V val_mem_data_write_o [31:0] $end
$var wire 32 W val_mem_data_read_i [31:0] $end
$var wire 32 X s2 [31:0] $end
$var wire 32 Y s1 [31:0] $end
$var wire 32 Z rs2 [31:0] $end
$var wire 32 [ mem_o [31:0] $end
$var wire 32 \ d [31:0] $end
$var wire 32 ] alu_o [31:0] $end
$var wire 10 ^ addr_mem_data_o [9:0] $end
$scope module ALU $end
$var wire 4 _ ALU_op [3:0] $end
$var wire 5 ` shift [4:0] $end
$var wire 32 a s2 [31:0] $end
$var wire 32 b s1 [31:0] $end
$var reg 32 c d [31:0] $end
$upscope $end
$scope module LIS $end
$var wire 3 d LIS_op [2:0] $end
$var wire 32 e addr_mem_i [31:0] $end
$var wire 32 f val_mem_write_i [31:0] $end
$var wire 32 g val_mem_read_i [31:0] $end
$var wire 10 h addr_mem_o [9:0] $end
$var reg 32 i val_mem_read_o [31:0] $end
$var reg 32 j val_mem_write_o [31:0] $end
$upscope $end
$upscope $end
$scope module mux_rs1_exec_inst $end
$var wire 32 k b [31:0] $end
$var wire 1 8 select $end
$var wire 32 l out [31:0] $end
$var wire 32 m a [31:0] $end
$upscope $end
$scope module mux_rs2_exec_inst $end
$var wire 32 n b [31:0] $end
$var wire 1 7 select $end
$var wire 32 o out [31:0] $end
$var wire 32 p a [31:0] $end
$upscope $end
$scope module program_counter_inst $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var reg 10 q addr [9:0] $end
$upscope $end
$scope module reg_file_inst $end
$var wire 1 ! clk $end
$var wire 32 r data_in [31:0] $end
$var wire 5 s r1_num_read [4:0] $end
$var wire 5 t r2_num_read [4:0] $end
$var wire 5 u r_num_write [4:0] $end
$var wire 1 " rst_n $end
$var wire 1 * we $end
$var wire 32 v rs2 [31:0] $end
$var wire 32 w rs1 [31:0] $end
$scope begin REG $end
$var integer 32 x j [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module mem_data_inst $end
$var wire 10 y addr [9:0] $end
$var wire 1 ! clk $end
$var wire 32 z data_in [31:0] $end
$var wire 1 " rst_n $end
$var wire 1 # we $end
$var wire 32 { data_out [31:0] $end
$scope begin MEM_WRITE $end
$var integer 32 | j [31:0] $end
$upscope $end
$upscope $end
$scope module mem_prog_inst $end
$var wire 10 } addr [9:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var reg 32 ~ data_out [31:0] $end
$scope begin MEM_READ $end
$var integer 32 !" j [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000000000 !"
bx ~
b0 }
b10000000000 |
bx {
bx z
bx y
b100000 x
bx w
bx v
bx u
bx t
bx s
bx r
b0 q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
b0 @
bx ?
bx >
bx =
b0 <
bx ;
bx :
bx 9
08
07
06
05
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
0*
z)
bx (
b0 '
bx &
bx %
bx $
0#
0"
0!
$end
#50000
b10000000000 !"
b10000000000 |
b100000 x
1!
#100000
0!
1"
#150000
b100 '
b100 <
b100 @
b100 q
b100 }
b10000000100000001000000010000 ;
b10000000100000001000000010000 \
b10000000100000001000000010000 r
b10000000100000001000000010000 [
b10000000100000001000000010000 i
b10000000100000001000000010000 &
b10000000100000001000000010000 -
b10000000100000001000000010000 W
b10000000100000001000000010000 g
b10000000100000001000000010000 {
b0 (
b0 =
b0 ^
b0 h
b0 y
b0 `
b0 ]
b0 c
b0 e
b0 /
b0 X
b0 a
b0 o
b0 1
b0 Y
b0 b
b0 l
b0 0
b0 m
b0 w
b10 >
b10 C
b10 U
b10 d
b0 9
b0 L
b0 n
17
b0 ?
b0 B
b0 T
b0 _
b1 2
b1 Q
b1 u
b0 4
b0 N
b0 s
1*
15
16
b0 S
b0 R
b1 H
b10000000000 G
b1000000000000 J
b1 P
b0 F
b10 I
b10 D
b0 E
b11 M
b10000010000011 $
b10000010000011 +
b10000010000011 A
b10000010000011 ~
1!
#200000
0!
#250000
b1000 '
b1000 <
b1000 @
b1000 q
b1000 }
b11110000010010100001110000001111 ;
b11110000010010100001110000001111 \
b11110000010010100001110000001111 r
b11110000010010100001110000001111 [
b11110000010010100001110000001111 i
b11110000010010100001110000001111 &
b11110000010010100001110000001111 -
b11110000010010100001110000001111 W
b11110000010010100001110000001111 g
b11110000010010100001110000001111 {
b1 (
b1 =
b1 ^
b1 h
b1 y
b1 `
b1 ]
b1 c
b1 e
b1 /
b1 X
b1 a
b1 o
b1 9
b1 L
b1 n
b10 2
b10 Q
b10 u
b1 S
b10 H
b1 G
b1010000000000 J
b10 P
b1 F
b100000010 I
1*
16
15
17
b100000010000100000011 $
b100000010000100000011 +
b100000010000100000011 A
b100000010000100000011 ~
1!
#300000
0!
#350000
b1100 '
b1100 <
b1100 @
b1100 q
b1100 }
b10001000100010001000100010001 ;
b10001000100010001000100010001 \
b10001000100010001000100010001 r
b10001000100010001000100010001 [
b10001000100010001000100010001 i
b10001000100010001000100010001 &
b10001000100010001000100010001 -
b10001000100010001000100010001 W
b10001000100010001000100010001 g
b10001000100010001000100010001 {
b10 (
b10 =
b10 ^
b10 h
b10 y
b10 `
b10 ]
b10 c
b10 e
b10 /
b10 X
b10 a
b10 o
b10 9
b10 L
b10 n
b11 2
b11 Q
b11 u
b10 S
b11 H
b10000000001 G
b1000000000001 J
b11 P
b10 F
b1000000010 I
1*
16
15
17
b1000000010000110000011 $
b1000000010000110000011 +
b1000000010000110000011 A
b1000000010000110000011 ~
1!
#400000
0!
#450000
b10000 '
b10000 <
b10000 @
b10000 q
b10000 }
b11111111111111111111111111111111 ;
b11111111111111111111111111111111 \
b11111111111111111111111111111111 r
b11111111111111111111111111111111 [
b11111111111111111111111111111111 i
b11111111111111111111111111111111 &
b11111111111111111111111111111111 -
b11111111111111111111111111111111 W
b11111111111111111111111111111111 g
b11111111111111111111111111111111 {
b11 (
b11 =
b11 ^
b11 h
b11 y
b11 `
b11 ]
b11 c
b11 e
b11 /
b11 X
b11 a
b11 o
b11 9
b11 L
b11 n
b100 2
b100 Q
b100 u
b11 S
b100 H
b10 G
b1010000000001 J
b100 P
b11 F
b1100000010 I
1*
16
15
17
b1100000010001000000011 $
b1100000010001000000011 +
b1100000010001000000011 A
b1100000010001000000011 ~
1!
#500000
0!
#550000
b10100 '
b10100 <
b10100 @
b10100 q
b10100 }
b1010 (
b1010 =
b1010 ^
b1010 h
b1010 y
b0 &
b0 -
b0 W
b0 g
b0 {
b1010 `
b1010 ]
b1010 c
b1010 e
b1000000010000 %
b1000000010000 ,
b1000000010000 V
b1000000010000 j
b1000000010000 z
b1010 /
b1010 X
b1010 a
b1010 o
b10000000100000001000000010000 .
b10000000100000001000000010000 Z
b10000000100000001000000010000 f
b10000000100000001000000010000 p
b10000000100000001000000010000 v
b110 >
b110 C
b110 U
b110 d
1#
b1010 9
b1010 L
b1010 n
b1 3
b1 O
b1 t
b1 S
b1010 H
b101 G
b110000000000 J
b1010 P
b1 F
b100000001 I
b1 D
b100011 M
0*
16
05
17
b100000001010100100011 $
b100000001010100100011 +
b100000001010100100011 A
b100000001010100100011 ~
1!
#600000
0!
#650000
b11000 '
b11000 <
b11000 @
b11000 q
b11000 }
b1011 (
b1011 =
b1011 ^
b1011 h
b1011 y
b1011 `
b1011 ]
b1011 c
b1011 e
b1111 %
b1111 ,
b1111 V
b1111 j
b1111 z
b1011 /
b1011 X
b1011 a
b1011 o
b11110000010010100001110000001111 .
b11110000010010100001110000001111 Z
b11110000010010100001110000001111 f
b11110000010010100001110000001111 p
b11110000010010100001110000001111 v
b101 >
b101 C
b101 U
b101 d
b1011 9
b1011 L
b1011 n
b10 3
b10 O
b10 t
b10 S
b1011 H
b10000000101 G
b1 J
b1011 P
b10 F
b1000000000 I
b0 D
16
1#
17
b1000000000010110100011 $
b1000000000010110100011 +
b1000000000010110100011 A
b1000000000010110100011 ~
1!
#700000
0!
#750000
b11100 '
b11100 <
b11100 @
b11100 q
b11100 }
b1100 (
b1100 =
b1100 ^
b1100 h
b1100 y
b1100 `
b1100 ]
b1100 c
b1100 e
b10001 %
b10001 ,
b10001 V
b10001 j
b10001 z
b1100 /
b1100 X
b1100 a
b1100 o
b10001000100010001000100010001 .
b10001000100010001000100010001 Z
b10001000100010001000100010001 f
b10001000100010001000100010001 p
b10001000100010001000100010001 v
b1100 9
b1100 L
b1100 n
b11 3
b11 O
b11 t
b11 S
b1100 H
b110 G
b10000000001 J
b1100 P
b11 F
b1100000000 I
16
1#
17
b1100000000011000100011 $
b1100000000011000100011 +
b1100000000011000100011 A
b1100000000011000100011 ~
1!
#800000
0!
#850000
b100000 '
b100000 <
b100000 @
b100000 q
b100000 }
b1101 (
b1101 =
b1101 ^
b1101 h
b1101 y
b1101 `
b1101 ]
b1101 c
b1101 e
b11111111111111111111111111111111 %
b11111111111111111111111111111111 ,
b11111111111111111111111111111111 V
b11111111111111111111111111111111 j
b11111111111111111111111111111111 z
b1101 /
b1101 X
b1101 a
b1101 o
b11111111111111111111111111111111 .
b11111111111111111111111111111111 Z
b11111111111111111111111111111111 f
b11111111111111111111111111111111 p
b11111111111111111111111111111111 v
b111 >
b111 C
b111 U
b111 d
b1101 9
b1101 L
b1101 n
b100 3
b100 O
b100 t
b100 S
b1101 H
b10000000110 G
b1000000000010 J
b1101 P
b100 F
b10000000010 I
b10 D
16
1#
17
b10000000010011010100011 $
b10000000010011010100011 +
b10000000010011010100011 A
b10000000010011010100011 ~
1!
#900000
0!
#950000
b100100 '
b100100 <
b100100 @
b100100 q
b100100 }
b1000000010000 &
b1000000010000 -
b1000000010000 W
b1000000010000 g
b1000000010000 {
b1010 (
b1010 =
b1010 ^
b1010 h
b1010 y
b1000000010000 ;
b1000000010000 \
b1000000010000 r
b1010 `
b1010 ]
b1010 c
b1010 e
b1000000010000 [
b1000000010000 i
b1010 /
b1010 X
b1010 a
b1010 o
b10 >
b10 C
b10 U
b10 d
b1010 9
b1010 L
b1010 n
b101 2
b101 Q
b101 u
1*
15
b1010 S
b101 H
b10000000010 G
b1000000000101 J
b101 P
b1010 F
b101000000010 I
b11 M
16
0#
17
b101000000010001010000011 $
b101000000010001010000011 +
b101000000010001010000011 A
b101000000010001010000011 ~
1!
#1000000
0!
#1050000
b101000 '
b101000 <
b101000 @
b101000 q
b101000 }
bx [
bx i
bx &
bx -
bx W
bx g
bx {
b1111111111 (
b1111111111 =
b1111111111 ^
b1111111111 h
b1111111111 y
b11111 `
b11111111111111111111111111111111 ]
b11111111111111111111111111111111 c
b11111111111111111111111111111111 e
b11111111111111111111111111111111 ;
b11111111111111111111111111111111 \
b11111111111111111111111111111111 r
b11111111111111111111111111111111 /
b11111111111111111111111111111111 X
b11111111111111111111111111111111 a
b11111111111111111111111111111111 o
b0 S
b0 H
b0 G
b0 J
b0 P
b0 F
b0 I
b0 D
b0 M
0*
06
05
07
b0 $
b0 +
b0 A
b0 ~
1!
#1100000
0!
#1150000
b101100 '
b101100 <
b101100 @
b101100 q
b101100 }
1!
#1200000
0!
