$date
	Sun Sep 22 17:54:59 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb $end
$scope module package_inst $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var wire 1 # we_mem_data $end
$var wire 32 $ val_mem_prog [31:0] $end
$var wire 32 % val_mem_data_write [31:0] $end
$var wire 32 & val_mem_data_read [31:0] $end
$var wire 10 ' addr_mem_prog [9:0] $end
$var wire 10 ( addr_mem_data [9:0] $end
$scope module core_inst $end
$var wire 1 ! clk $end
$var wire 1 ) is_branch_t $end
$var wire 1 " rst_n $end
$var wire 1 * we_reg_file $end
$var wire 1 # we_mem_data_o $end
$var wire 32 + val_mem_prog_i [31:0] $end
$var wire 32 , val_mem_data_write_o [31:0] $end
$var wire 32 - val_mem_data_read_i [31:0] $end
$var wire 32 . rs2_reg_file [31:0] $end
$var wire 32 / rs2_exec_unit_t [31:0] $end
$var wire 32 0 rs1_reg_file [31:0] $end
$var wire 32 1 rs1_exec_unit_t [31:0] $end
$var wire 5 2 r_num_write_reg_file [4:0] $end
$var wire 5 3 r2_num_read_reg_file [4:0] $end
$var wire 5 4 r1_num_read_reg_file [4:0] $end
$var wire 1 5 mem_to_reg_t $end
$var wire 1 6 is_load_store_t $end
$var wire 1 7 is_imm_rs2 $end
$var wire 1 8 is_imm_rs1 $end
$var wire 32 9 imm_val_rs2 [31:0] $end
$var wire 32 : imm_val_rs1 [31:0] $end
$var wire 32 ; data_in_reg_file [31:0] $end
$var wire 10 < addr_mem_prog_o [9:0] $end
$var wire 10 = addr_mem_data_o [9:0] $end
$var wire 3 > LIS_op_t [2:0] $end
$var wire 4 ? ALU_op_t [3:0] $end
$scope module controlUnit_inst $end
$var wire 10 @ pc_i [9:0] $end
$var wire 32 A instruction [31:0] $end
$var reg 4 B ALU_op [3:0] $end
$var reg 3 C LIS_op [2:0] $end
$var reg 3 D funct3 [2:0] $end
$var reg 7 E funct7 [6:0] $end
$var reg 12 F imm12 [11:0] $end
$var reg 12 G imm12b [11:0] $end
$var reg 20 H imm20 [19:0] $end
$var reg 20 I imm20j [19:0] $end
$var reg 32 J imm_val_rs1_o [31:0] $end
$var reg 32 K imm_val_rs2_o [31:0] $end
$var reg 1 8 is_imm_rs1_o $end
$var reg 1 7 is_imm_rs2_o $end
$var reg 1 6 is_load_store $end
$var reg 1 5 mem_to_reg $end
$var reg 1 # mem_w $end
$var reg 7 L opcode [6:0] $end
$var reg 5 M r1_addr [4:0] $end
$var reg 5 N r2_addr [4:0] $end
$var reg 5 O rd [4:0] $end
$var reg 5 P reg_addr [4:0] $end
$var reg 1 * reg_r $end
$var reg 5 Q rs1 [4:0] $end
$var reg 5 R rs2 [4:0] $end
$upscope $end
$scope module exec_unit_inst $end
$var wire 4 S ALU_op [3:0] $end
$var wire 3 T LIS_op [2:0] $end
$var wire 1 ) is_branch $end
$var wire 1 6 is_loadstore $end
$var wire 32 U val_mem_data_write_o [31:0] $end
$var wire 32 V val_mem_data_read_i [31:0] $end
$var wire 32 W s2 [31:0] $end
$var wire 32 X s1 [31:0] $end
$var wire 32 Y mem_o [31:0] $end
$var wire 32 Z d [31:0] $end
$var wire 32 [ alu_o [31:0] $end
$var wire 10 \ addr_mem_data_o [9:0] $end
$scope module ALU $end
$var wire 4 ] ALU_op [3:0] $end
$var wire 5 ^ shift [4:0] $end
$var wire 32 _ s2 [31:0] $end
$var wire 32 ` s1 [31:0] $end
$var reg 32 a d [31:0] $end
$upscope $end
$scope module LIS $end
$var wire 3 b LIS_op [2:0] $end
$var wire 32 c addr_mem_i [31:0] $end
$var wire 32 d val_mem_write_i [31:0] $end
$var wire 32 e val_mem_read_i [31:0] $end
$var wire 10 f addr_mem_o [9:0] $end
$var reg 32 g val_mem_read_o [31:0] $end
$var reg 32 h val_mem_write_o [31:0] $end
$upscope $end
$upscope $end
$scope module mux_rs1_exec_inst $end
$var wire 32 i b [31:0] $end
$var wire 1 8 select $end
$var wire 32 j out [31:0] $end
$var wire 32 k a [31:0] $end
$upscope $end
$scope module mux_rs2_exec_inst $end
$var wire 32 l b [31:0] $end
$var wire 1 7 select $end
$var wire 32 m out [31:0] $end
$var wire 32 n a [31:0] $end
$upscope $end
$scope module program_counter_inst $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var reg 10 o addr [9:0] $end
$upscope $end
$scope module reg_file_inst $end
$var wire 1 ! clk $end
$var wire 32 p data_in [31:0] $end
$var wire 5 q r1_num_read [4:0] $end
$var wire 5 r r2_num_read [4:0] $end
$var wire 5 s r_num_write [4:0] $end
$var wire 1 " rst_n $end
$var wire 1 * we $end
$var wire 32 t rs2 [31:0] $end
$var wire 32 u rs1 [31:0] $end
$scope begin REG $end
$var integer 32 v j [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module mem_data_inst $end
$var wire 10 w addr [9:0] $end
$var wire 1 ! clk $end
$var wire 32 x data_in [31:0] $end
$var wire 1 " rst_n $end
$var wire 1 # we $end
$var wire 32 y data_out [31:0] $end
$scope begin MEM_WRITE $end
$var integer 32 z j [31:0] $end
$upscope $end
$upscope $end
$scope module mem_prog_inst $end
$var wire 10 { addr [9:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var reg 32 | data_out [31:0] $end
$scope begin MEM_READ $end
$var integer 32 } j [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000000000 }
bx |
b0 {
b10000000000 z
bx y
bx x
bx w
b100000 v
bx u
bx t
bx s
bx r
bx q
bx p
b0 o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
b0 @
bx ?
bx >
bx =
b0 <
bx ;
bx :
bx 9
08
07
06
05
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
0*
z)
bx (
b0 '
bx &
bx %
bx $
0#
0"
0!
$end
#50000
b10000000000 }
b10000000000 z
b100000 v
1!
#100000
0!
1"
#150000
b100 '
b100 <
b100 @
b100 o
b100 {
b1111 ;
b1111 Z
b1111 p
b1111 Y
b1111 g
b11110000010010100001110000001111 &
b11110000010010100001110000001111 -
b11110000010010100001110000001111 V
b11110000010010100001110000001111 e
b11110000010010100001110000001111 y
b1 (
b1 =
b1 \
b1 f
b1 w
b1 ^
b1 [
b1 a
b1 c
b1 /
b1 W
b1 _
b1 d
b1 m
b0 1
b0 X
b0 `
b0 j
b0 0
b0 k
b0 u
b0 >
b0 C
b0 T
b0 b
b1 9
b1 K
b1 l
17
b0 ?
b0 B
b0 S
b0 ]
b11 2
b11 P
b11 s
b0 4
b0 M
b0 q
1*
15
16
b1 R
b0 Q
b10000000001 G
b10000000000 I
b11 O
b1 F
b100000000 H
b0 D
b0 E
b11 L
b100000000000110000011 $
b100000000000110000011 +
b100000000000110000011 A
b100000000000110000011 |
1!
#200000
0!
#250000
b1000 '
b1000 <
b1000 @
b1000 o
b1000 {
b1110000001111 ;
b1110000001111 Z
b1110000001111 p
b1110000001111 Y
b1110000001111 g
b1 >
b1 C
b1 T
b1 b
b100 2
b100 P
b100 s
b10 G
b110000000000 I
b100 O
b100000001 H
b1 D
1*
16
15
17
b100000001001000000011 $
b100000001001000000011 +
b100000001001000000011 A
b100000001001000000011 |
1!
#300000
0!
#350000
b1100 '
b1100 <
b1100 @
b1100 o
b1100 {
b11110000010010100001110000001111 ;
b11110000010010100001110000001111 Z
b11110000010010100001110000001111 p
b11110000010010100001110000001111 Y
b11110000010010100001110000001111 g
b10 >
b10 C
b10 T
b10 b
b101 2
b101 P
b101 s
b10000000010 G
b1010000000000 I
b101 O
b100000010 H
b10 D
1*
16
15
17
b100000010001010000011 $
b100000010001010000011 +
b100000010001010000011 A
b100000010001010000011 |
1!
#400000
0!
#450000
b10000 '
b10000 <
b10000 @
b10000 o
b10000 {
b1110000001111 ;
b1110000001111 Z
b1110000001111 p
b1110000001111 Y
b1110000001111 g
b100 >
b100 C
b100 T
b100 b
b110 2
b110 P
b110 s
b11 G
b10110000000000 I
b110 O
b100000101 H
b101 D
1*
16
15
17
b100000101001100000011 $
b100000101001100000011 +
b100000101001100000011 A
b100000101001100000011 |
1!
#500000
0!
#550000
b10100 '
b10100 <
b10100 @
b10100 o
b10100 {
b1111 ;
b1111 Z
b1111 p
b1111 Y
b1111 g
b11 >
b11 C
b11 T
b11 b
b111 2
b111 P
b111 s
b10000000011 G
b10010000000000 I
b111 O
b100000100 H
b100 D
1*
16
15
17
b100000100001110000011 $
b100000100001110000011 +
b100000100001110000011 A
b100000100001110000011 |
1!
#600000
0!
