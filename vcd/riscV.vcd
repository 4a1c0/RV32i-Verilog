$date
	Wed Jan 29 18:54:37 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module csr_test $end
$scope module TB $end
$scope module top_inst $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var wire 4 # write_transfer [3:0] $end
$var wire 1 $ we_mem_data $end
$var wire 32 % val_mem_prog [31:0] $end
$var wire 32 & val_mem_data_write [31:0] $end
$var wire 32 ' val_mem_data_read [31:0] $end
$var wire 10 ( addr_mem_prog [9:0] $end
$var wire 10 ) addr_mem_data [9:0] $end
$scope module core_inst $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var wire 4 * write_transfer_mem_data_o [3:0] $end
$var wire 1 + we_reg_file $end
$var wire 1 $ we_mem_data_o $end
$var wire 32 , val_mem_prog_i [31:0] $end
$var wire 32 - val_mem_data_write_o [31:0] $end
$var wire 32 . val_mem_data_read_i [31:0] $end
$var wire 32 / rs2_reg_file [31:0] $end
$var wire 32 0 rs1_reg_file [31:0] $end
$var wire 32 1 reg_pc [31:0] $end
$var wire 5 2 r_num_write_reg_file [4:0] $end
$var wire 5 3 r2_num_read_reg_file [4:0] $end
$var wire 5 4 r1_num_read_reg_file [4:0] $end
$var wire 32 5 pc [31:0] $end
$var wire 32 6 new_pc [31:0] $end
$var wire 1 7 is_load_store_t $end
$var wire 1 8 is_conditional_t $end
$var wire 1 9 is_branch_t $end
$var wire 32 : imm_val_t [31:0] $end
$var wire 2 ; data_target_t [1:0] $end
$var wire 2 < data_origin_t [1:0] $end
$var wire 32 = data_in_reg_file [31:0] $end
$var wire 32 > csr_val_w [31:0] $end
$var wire 32 ? csr_val_r [31:0] $end
$var wire 3 @ csr_op_t [2:0] $end
$var wire 12 A csr_addr_t [11:0] $end
$var wire 10 B addr_mem_prog_o [9:0] $end
$var wire 10 C addr_mem_data_o [9:0] $end
$var wire 3 D LIS_op_t [2:0] $end
$var wire 2 E BR_op_t [1:0] $end
$var wire 4 F ALU_op_t [3:0] $end
$scope module controlUnit_inst $end
$var wire 32 G instruction [31:0] $end
$var reg 4 H ALU_op [3:0] $end
$var reg 2 I BR_op_o [1:0] $end
$var reg 3 J LIS_op [2:0] $end
$var reg 12 K csr_addr_o [11:0] $end
$var reg 32 L csr_data_o [31:0] $end
$var reg 3 M csr_op_o [2:0] $end
$var reg 2 N data_origin_o [1:0] $end
$var reg 2 O data_target_o [1:0] $end
$var reg 3 P funct3 [2:0] $end
$var reg 7 Q funct7 [6:0] $end
$var reg 12 R imm12 [11:0] $end
$var reg 12 S imm12b [11:0] $end
$var reg 12 T imm12s [11:0] $end
$var reg 20 U imm20 [19:0] $end
$var reg 20 V imm20j [19:0] $end
$var reg 32 W imm_val_o [31:0] $end
$var reg 1 9 is_branch_o $end
$var reg 1 8 is_conditional_o $end
$var reg 1 7 is_load_store $end
$var reg 1 $ mem_w $end
$var reg 7 X opcode [6:0] $end
$var reg 5 Y r1_addr [4:0] $end
$var reg 5 Z r2_addr [4:0] $end
$var reg 5 [ rd [4:0] $end
$var reg 5 \ reg_addr [4:0] $end
$var reg 1 + reg_w $end
$var reg 5 ] rs1 [4:0] $end
$var reg 5 ^ rs2 [4:0] $end
$var reg 4 _ write_transfer_o [3:0] $end
$upscope $end
$scope module crs_unit_inst $end
$var wire 1 ! clk $end
$var wire 12 ` csr_addr_i [11:0] $end
$var wire 3 a csr_op_i [2:0] $end
$var wire 32 b csr_val_i [31:0] $end
$var wire 1 " rst_n $end
$var wire 64 c timer_val_i [63:0] $end
$var reg 32 d csr_val_o [31:0] $end
$var reg 64 e timer_val_o [63:0] $end
$var reg 1 f timer_we_o $end
$scope module timer_inst $end
$var wire 1 ! clk $end
$var wire 1 " rst_n $end
$var wire 64 g val_i [63:0] $end
$var wire 1 f we_i $end
$var reg 64 h val_o [63:0] $end
$upscope $end
$upscope $end
$scope module exec_unit_inst $end
$var wire 4 i ALU_op [3:0] $end
$var wire 2 j BR_op [1:0] $end
$var wire 3 k LIS_op [2:0] $end
$var wire 3 l csr_op_i [2:0] $end
$var wire 32 m csr_val_i [31:0] $end
$var wire 2 n data_origin_i [1:0] $end
$var wire 2 o data_target_i [1:0] $end
$var wire 32 p imm_val_i [31:0] $end
$var wire 1 9 is_branch_i $end
$var wire 1 8 is_conditional_i $end
$var wire 1 7 is_loadstore $end
$var wire 1 q zero_alu_result $end
$var wire 32 r val_mem_data_write_o [31:0] $end
$var wire 32 s val_mem_data_read_i [31:0] $end
$var wire 32 t rs2_i [31:0] $end
$var wire 32 u rs1_i [31:0] $end
$var wire 32 v reg_pc_i [31:0] $end
$var wire 32 w pc_i [31:0] $end
$var wire 32 x new_pc_offset_o [31:0] $end
$var wire 32 y mem_o [31:0] $end
$var wire 32 z alu_o [31:0] $end
$var wire 10 { addr_mem_data_o [9:0] $end
$var reg 32 | d_o [31:0] $end
$var reg 32 } s1_ALU [31:0] $end
$var reg 32 ~ s2_ALU [31:0] $end
$scope module ALU $end
$var wire 4 !" ALU_op [3:0] $end
$var wire 32 "" s1 [31:0] $end
$var wire 32 #" s2 [31:0] $end
$var wire 1 q zero_o $end
$var wire 5 $" shift [4:0] $end
$var reg 32 %" d [31:0] $end
$upscope $end
$scope module BR $end
$var wire 1 q ALU_zero_i $end
$var wire 2 &" BR_op_i [1:0] $end
$var wire 32 '" alu_d [31:0] $end
$var wire 32 (" imm_i [31:0] $end
$var wire 1 9 is_branch_i $end
$var wire 1 8 is_conditional_i $end
$var wire 32 )" reg_pc_i [31:0] $end
$var wire 32 *" pc_i [31:0] $end
$var wire 32 +" new_pc_o [31:0] $end
$var reg 32 ," offset [31:0] $end
$upscope $end
$scope module LIS $end
$var wire 3 -" LIS_op [2:0] $end
$var wire 32 ." addr_mem_i [31:0] $end
$var wire 32 /" val_mem_write_i [31:0] $end
$var wire 32 0" val_mem_read_i [31:0] $end
$var wire 10 1" addr_mem_o [9:0] $end
$var reg 32 2" val_mem_read_o [31:0] $end
$var reg 32 3" val_mem_write_o [31:0] $end
$upscope $end
$upscope $end
$scope module program_counter_inst $end
$var wire 1 ! clk $end
$var wire 32 4" new_pc_i [31:0] $end
$var wire 1 " rst_n $end
$var reg 32 5" pc [31:0] $end
$var reg 32 6" reg_pc_o [31:0] $end
$upscope $end
$scope module reg_file_inst $end
$var wire 1 ! clk $end
$var wire 32 7" data_in [31:0] $end
$var wire 5 8" r1_num_read [4:0] $end
$var wire 5 9" r2_num_read [4:0] $end
$var wire 5 :" r_num_write [4:0] $end
$var wire 1 " rst_n $end
$var wire 1 + we $end
$var wire 32 ;" rs2 [31:0] $end
$var wire 32 <" rs1 [31:0] $end
$scope begin REG $end
$var integer 32 =" j [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module mem_data_inst $end
$var wire 10 >" addr [9:0] $end
$var wire 1 ! clk $end
$var wire 32 ?" data_in [31:0] $end
$var wire 1 " rst_n $end
$var wire 1 $ we $end
$var wire 4 @" write_transfer_i [3:0] $end
$var wire 32 A" data_out [31:0] $end
$scope begin MEM_WRITE $end
$var integer 32 B" j [31:0] $end
$upscope $end
$upscope $end
$scope module mem_prog_inst $end
$var wire 10 C" addr [9:0] $end
$var wire 1 ! clk $end
$var wire 32 D" data_out [31:0] $end
$var wire 1 " rst_n $end
$scope begin MEM_READ $end
$var integer 32 E" j [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000000000 E"
b0 D"
b0 C"
b100000000 B"
b0 A"
b0 @"
b0 ?"
b0 >"
b100000 ="
b0 <"
b0 ;"
b0 :"
b0 9"
b0 8"
b0 7"
b0 6"
b0 5"
b100 4"
b0 3"
b0 2"
b0 1"
b0 0"
b0 /"
b0 ."
b0 -"
b0 ,"
b100 +"
b0 *"
b0 )"
b0 ("
b0 '"
b0 &"
b0 %"
b0 $"
b0 #"
b0 ""
b0 !"
b0 ~
b0 }
b0 |
b0 {
b0 z
b0 y
b100 x
b0 w
b0 v
b0 u
b0 t
b0 s
b0 r
1q
b0 p
b0 o
b0 n
bx m
b0 l
b0 k
b0 j
b0 i
b0 h
b0 g
0f
b0 e
bx d
b0 c
b0 b
b0 a
b0 `
b0 _
b0 ^
b0 ]
b0 \
b0 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
bx ?
b0 >
b0 =
b0 <
b0 ;
b0 :
09
08
07
b100 6
b0 5
b0 4
b0 3
b0 2
b0 1
b0 0
b0 /
b0 .
b0 -
b0 ,
0+
b0 *
b0 )
b0 (
b0 '
b0 &
b0 %
0$
b0 #
0"
0!
$end
#50000
b10000000000 E"
b100000000 B"
b100000 ="
1!
#100000
bx =
bx |
bx 7"
b10000 y
b10000 2"
b11 ;
b11 O
b11 o
b10 @
b10 M
b10 a
b10 l
b110000000000 A
b110000000000 K
b110000000000 `
b1 2
b1 \
b1 :"
1+
b110000000001 T
b111000000000 S
b10000001001000000000 V
b1 [
b110000000000 R
b11000000000000000010 U
b10 P
b1100000 Q
b1110011 X
b10000000100000001000000010000 '
b10000000100000001000000010000 .
b10000000100000001000000010000 s
b10000000100000001000000010000 0"
b10000000100000001000000010000 A"
0!
1"
b11000000000000000010000011110011 %
b11000000000000000010000011110011 ,
b11000000000000000010000011110011 G
b11000000000000000010000011110011 D"
#150000
b1 ^
b110000000010 T
b101000000001 S
b10000001011000000000 V
b10 [
b110000000001 R
b11000000000100000010 U
b10 2
b10 \
b10 :"
b110000000001 A
b110000000001 K
b110000000001 `
b10 @
b10 M
b10 a
b10 l
b11 ;
b11 O
b11 o
1+
b11000000000100000010000101110011 %
b11000000000100000010000101110011 ,
b11000000000100000010000101110011 G
b11000000000100000010000101110011 D"
b1000 6
b1000 x
b1000 +"
b1000 4"
b100 (
b100 B
b100 C"
b0 =
b0 |
b0 7"
b100 5
b100 v
b100 w
b100 )"
b100 *"
b100 5"
b1 c
b1 h
b0 ?
b0 d
b0 m
1!
#200000
0!
#250000
b10 ^
b110000000011 T
b111000000001 S
b10000001001000000001 V
b11 [
b110000000010 R
b11000000001000000010 U
b11 2
b11 \
b11 :"
b110000000010 A
b110000000010 K
b110000000010 `
b10 @
b10 M
b10 a
b10 l
b11 ;
b11 O
b11 o
1+
b11000000001000000010000111110011 %
b11000000001000000010000111110011 ,
b11000000001000000010000111110011 G
b11000000001000000010000111110011 D"
b1100 6
b1100 x
b1100 +"
b1100 4"
b1 =
b1 |
b1 7"
b1000 (
b1000 B
b1000 C"
b1 ?
b1 d
b1 m
b10 c
b10 h
b100 1
b100 6"
b1000 5
b1000 v
b1000 w
b1000 )"
b1000 *"
b1000 5"
1!
#300000
0!
#350000
b0 ^
b0 T
b0 S
b0 V
b0 [
b0 R
b0 U
b0 P
b0 Q
b0 X
b0 2
b0 \
b0 :"
b0 A
b0 K
b0 `
b0 @
b0 M
b0 a
b0 l
b0 ;
b0 O
b0 o
0+
b0 %
b0 ,
b0 G
b0 D"
b10000 6
b10000 x
b10000 +"
b10000 4"
b1100 (
b1100 B
b1100 C"
b0 =
b0 |
b0 7"
b1000 1
b1000 6"
b1100 5
b1100 v
b1100 w
b1100 )"
b1100 *"
b1100 5"
b11 c
b11 h
b10 ?
b10 d
b10 m
1!
#400000
0!
#450000
b10100 6
b10100 x
b10100 +"
b10100 4"
b10000 (
b10000 B
b10000 C"
b100 c
b100 h
b1100 1
b1100 6"
b10000 5
b10000 v
b10000 w
b10000 )"
b10000 *"
b10000 5"
1!
#500000
0!
